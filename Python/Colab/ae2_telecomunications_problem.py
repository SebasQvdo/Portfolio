# -*- coding: utf-8 -*-
"""AE2 - Telecomunications Problem

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yfJq0xmwzDGVS8sP_NJ4Z2RQbg-FXjE5
"""

import networkx as nx
import matplotlib.pyplot as plt

cities = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']

all_links = [
    ('A', 'B', 200), ('A', 'C', 250), ('A', 'D', 220), ('A', 'E', 280), ('A', 'F', 160),
    ('A', 'G', 240), ('A', 'H', 230), ('A', 'I', 220), ('A', 'J', 210),
    ('B', 'C', 170), ('B', 'D', 210), ('B', 'E', 190), ('B', 'F', 160), ('B', 'G', 180),
    ('B', 'H', 240), ('B', 'I', 230), ('B', 'J', 220),
    ('C', 'D', 180), ('C', 'E', 200), ('C', 'F', 190), ('C', 'G', 170), ('C', 'H', 200),
    ('C', 'I', 180), ('C', 'J', 220),
    ('D', 'E', 220), ('D', 'F', 180), ('D', 'G', 200), ('D', 'H', 190), ('D', 'I', 210),
    ('D', 'J', 230),
    ('E', 'F', 230), ('E', 'G', 210), ('E', 'H', 270), ('E', 'I', 280), ('E', 'J', 270),
    ('F', 'G', 220), ('F', 'H', 200), ('F', 'I', 190), ('F', 'J', 280),
    ('G', 'H', 210), ('G', 'I', 290), ('G', 'J', 180),
    ('H', 'I', 200), ('H', 'J', 290),
    ('I', 'J', 210)
]

print(f"{len(cities)} cities with {len(all_links)} possible links.")

### Greedy Algorithm: Strongest Neighbor ###

# Node graph
solution_graph = nx.Graph()
solution_graph.add_nodes_from(cities)

greedy_edges = []
total_bandwidth = 0

# Sort cities alphabetically
sorted_cities = sorted(cities)

for city in sorted_cities:
    # Find links connected to this specific city
    my_links = []
    for u, v, w in all_links:
        if u == city or v == city:
            my_links.append((u, v, w))

    # Sort links by bandwidth (highest to lowest)
    my_links.sort(key=lambda x: x[2], reverse=True)

    # Try to add the best link for this city
    for u, v, w in my_links:
        if solution_graph.has_edge(u, v):
            continue

        # Temporarily add the edge
        solution_graph.add_edge(u, v, bandwidth=w)

        # Check for cycles
        try:
            # If no cycle: error
            cycle = nx.find_cycle(solution_graph)

            # If we reached here, there is a cycle, so we must remove the edge we just added.
            solution_graph.remove_edge(u, v)

        except nx.NetworkXNoCycle:
            # No cycle was found
            greedy_edges.append((u, v, w))
            total_bandwidth += w
            print(f"City {city}: {u}-{v} ({w} Mbps)")
            # Once we pick the best valid link for this city, we stop looking for this city
            break

# For the final graph
mst_edges = greedy_edges

print(f"\nGreedy Solution Bandwidth: {total_bandwidth} Mbps")
print(f"Edges Selected: {len(mst_edges)}")

### Local Search by Swapping ###

# Create a graph for the local search
ls_graph = nx.Graph()
ls_graph.add_nodes_from(cities)
for u, v, w in mst_edges:
    ls_graph.add_edge(u, v, bandwidth=w)

current_solution = list(mst_edges)
improved = True

print(f"New links using Local Search:")

while improved:
    improved = False

    # Edges not used in the current solution
    current_edges_set = set()

    for u, v, w in current_solution:
        # Ensure a-b is the same as b-a
        edge = tuple(sorted((u, v)))
        current_edges_set.add(edge)

    unused_links = []
    for u, v, w in all_links:
        edge = tuple(sorted((u, v)))
        if edge not in current_edges_set:
            unused_links.append((u, v, w))

    # Sort unused links
    unused_links.sort(key=lambda x: x[2], reverse=True)

    for u, v, w_new in unused_links:
        # Try adding this unused edge
        ls_graph.add_edge(u, v, bandwidth=w_new)

        try:
            # Check for a cycle due to the new edge
            cycle = nx.find_cycle(ls_graph)

            # Find the weakest link in this new cycle
            min_weight = float('inf')
            weakest_edge = None

            # Look and prioritize edges with highest weight in the cycle
            for cu, cv in cycle:
                cw = ls_graph[cu][cv]['bandwidth']
                if cw < min_weight:
                    min_weight = cw
                    weakest_edge = (cu, cv)

            # Check if the new link better than the weakest link in the cycle
            if w_new > min_weight:
                # Swap for better edge
                ls_graph.remove_edge(weakest_edge[0], weakest_edge[1])

                # Update our list of tuples
                edge_to_remove = None
                for i, (sol_u, sol_v, sol_w) in enumerate(current_solution):
                    if set((sol_u, sol_v)) == set((weakest_edge[0], weakest_edge[1])):
                        edge_to_remove = i
                        break
                if edge_to_remove is not None:
                    removed_data = current_solution.pop(edge_to_remove)

                # Add new edge tuple
                current_solution.append((u, v, w_new))

                print(f"+ Added {u}-{v} ({w_new}), Removed {weakest_edge[0]}-{weakest_edge[1]} ({min_weight})")
                improved = True
                break # Restart loop since graph changed
            else:
                # If new edge isn't better, remove it and try next link.
                ls_graph.remove_edge(u, v)

        except nx.NetworkXNoCycle:
            ####This shouldn't happen in a full spanning tree, but safety check
            pass

# Calculate new total
current_total_bandwidth = sum([w for u, v, w in current_solution])
print(f"\nLocal Search Bandwidth: {current_total_bandwidth} Mbps")

### Node Visualization Graph ###

fig, axes = plt.subplots(1, 2, figsize=(18, 8))


## Graph for Greedy Solution
graph_greedy = nx.Graph()
graph_greedy.add_nodes_from(cities)
for u, v, bw in mst_edges:
    graph_greedy.add_edge(u, v, bandwidth=bw)

# Using a fixed seed so it doesnt iterate through different visualizations
pos_greedy = nx.spring_layout(graph_greedy, seed=42, iterations=100)

nx.draw_networkx_nodes(graph_greedy, pos_greedy, ax=axes[0], node_color='lightblue', node_size=1000)
nx.draw_networkx_edges(graph_greedy, pos_greedy, ax=axes[0], width=2, alpha=0.7, edge_color='gray')

node_labels_greedy = {node: node for node in graph_greedy.nodes()}
nx.draw_networkx_labels(graph_greedy, pos_greedy, labels=node_labels_greedy, ax=axes[0], font_size=10, font_weight='bold')

edge_labels_greedy = {(u, v): d['bandwidth'] for u, v, d in graph_greedy.edges(data=True)}
nx.draw_networkx_edge_labels(graph_greedy, pos_greedy, edge_labels=edge_labels_greedy, ax=axes[0], font_color='red', font_size=8)

axes[0].set_title(f'Greedy Solution (Bandwidth: {total_bandwidth} Mbps)')
axes[0].axis('off')


## Graph for Local Search Solution
graph_local_search = nx.Graph()
graph_local_search.add_nodes_from(cities)
for u, v, bw in current_solution:
    graph_local_search.add_edge(u, v, bandwidth=bw)

pos_local_search = nx.spring_layout(graph_local_search, seed=42, iterations=100)

nx.draw_networkx_nodes(graph_local_search, pos_local_search, ax=axes[1], node_color='lightgreen', node_size=1000)
nx.draw_networkx_edges(graph_local_search, pos_local_search, ax=axes[1], width=2, alpha=0.7, edge_color='gray')

node_labels_local_search = {node: node for node in graph_local_search.nodes()}
nx.draw_networkx_labels(graph_local_search, pos_local_search, labels=node_labels_local_search, ax=axes[1], font_size=10, font_weight='bold')

edge_labels_local_search = {(u, v): d['bandwidth'] for u, v, d in graph_local_search.edges(data=True)}
nx.draw_networkx_edge_labels(graph_local_search, pos_local_search, edge_labels=edge_labels_local_search, ax=axes[1], font_color='red', font_size=8)

axes[1].set_title(f'Local Search Solution (Bandwidth: {current_total_bandwidth} Mbps)')
axes[1].axis('off')

plt.tight_layout()
plt.show()