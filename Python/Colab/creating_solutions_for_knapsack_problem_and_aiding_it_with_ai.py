# -*- coding: utf-8 -*-
"""Creating solutions for knapsack problem and aiding it with AI

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OBGDtT6PaAuUJqw5V3otHcsgrspiLnFe

### Knapsack Problem Solution

This notebook will solve the 0/1 knapsack problem for the given items and knapsack capacity. The goal is to maximize the total benefit of items placed in the knapsack without exceeding its weight capacity.

Since the item weights include decimal values, we will scale all weights and the knapsack capacity by a factor of 100 to convert them into integers. This allows us to use a standard dynamic programming approach for the 0/1 knapsack problem.

Let's define the items and the knapsack capacity first.
"""

# Define the items: each item is a dictionary with 'name', 'weight', and 'benefit'
items_data = [
    {'name': 'Water', 'weight': 2, 'benefit': 7},
    {'name': 'Chocolate', 'weight': 0.25, 'benefit': 10},
    {'name': 'Gatorade', 'weight': 1.1, 'benefit': 7},
    {'name': 'Camera', 'weight': 2, 'benefit': 6},
    {'name': 'Raincoat', 'weight': 0.75, 'benefit': 3},
    {'name': 'Towel', 'weight': 0.8, 'benefit': 5},
    {'name': 'First Aid Kit', 'weight': 3, 'benefit': 10},
    {'name': 'Flashlight', 'weight': 1.5, 'benefit': 7},
    {'name': 'Fruit', 'weight': 2.5, 'benefit': 8},
    {'name': 'Sandwiches', 'weight': 0.5, 'benefit': 5},
    {'name': 'Tacos', 'weight': 0.75, 'benefit': 8},
    {'name': 'Sleeping Bag', 'weight': 2.3, 'benefit': 4},
    {'name': 'Book', 'weight': 1.3, 'benefit': 8},
    {'name': 'Sunscreen', 'weight': 0.45, 'benefit': 9},
    {'name': 'Champagne', 'weight': 1.1, 'benefit': 5}
]

# Define the knapsack capacity
knapsack_capacity_kg = 10

# Scaling factor to convert decimal weights to integers
scaling_factor = 100

# Prepare items with scaled weights
items = []
for item in items_data:
    scaled_weight = int(item['weight'] * scaling_factor)
    items.append({'name': item['name'], 'weight': scaled_weight, 'benefit': item['benefit']})

scaled_knapsack_capacity = int(knapsack_capacity_kg * scaling_factor)

print(f"Original Knapsack Capacity: {knapsack_capacity_kg} kg")
print(f"Scaled Knapsack Capacity: {scaled_knapsack_capacity}")
print("Scaled Items:")
for item in items:
    print(f"  - {item['name']}: Weight={item['weight']}, Benefit={item['benefit']}")

# Knapsack solving algorithm

def solve_knapsack(items, capacity):
    n = len(items)
    # dp[i][w] will store the maximum benefit for first i items with capacity w
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]

    # Populate the dp table
    for i in range(1, n + 1):
        weight_i = items[i-1]['weight']
        benefit_i = items[i-1]['benefit']

        for w in range(1, capacity + 1):
            if weight_i <= w:
                # Option 1: Include item i
                # Option 2: Exclude item i
                dp[i][w] = max(benefit_i + dp[i-1][w - weight_i], dp[i-1][w])
            else:
                # Cannot include item i due to weight constraint
                dp[i][w] = dp[i-1][w]

    # The maximum benefit is in dp[n][capacity]
    max_benefit = dp[n][capacity]

    # Reconstruct the selected items
    selected_items = []
    w = capacity
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:
            selected_items.append(items_data[i-1]) # Use original item data for output
            w -= items[i-1]['weight']

    return max_benefit, selected_items

# Solve the knapsack problem with scaled values
max_benefit, selected_items_original = solve_knapsack(items, scaled_knapsack_capacity)

print(f"\nMaximum total benefit: {max_benefit}")
print("Selected items:")

total_weight_selected = 0
for item in selected_items_original:
    print(f"  - {item['name']} (Weight: {item['weight']} kg, Benefit: {item['benefit']})")
    total_weight_selected += item['weight']

print(f"Total weight of selected items: {total_weight_selected:.2f} kg")
print(f"Knapsack capacity: {knapsack_capacity_kg} kg")

# Brute force method

import itertools

# Re-using items_data and knapsack_capacity_kg from previous cells
# items_data = [
#     {'name': 'Agua', 'weight': 2, 'benefit': 7},
#     ... (full list as defined previously)
# ]
# knapsack_capacity_kg = 10

max_overall_benefit = 0
best_feasible_combination = []
best_feasible_weight = 0

n = len(items_data)

print("Exploring all possible combinations...")

# Iterate through all possible subsets (combinations) of items
# A bitmask approach effectively generates all 2^n subsets
for i in range(1 << n): # Loop from 0 to 2^n - 1
    current_combination = []
    current_weight = 0
    current_benefit = 0

    for j in range(n):
        # Check if the j-th item is in the current subset (represented by the i-th bit)
        if (i >> j) & 1:
            current_combination.append(items_data[j])
            current_weight += items_data[j]['weight']
            current_benefit += items_data[j]['benefit']

    # Check if the current combination is feasible (does not exceed knapsack capacity)
    if current_weight <= knapsack_capacity_kg:
        # Check if this feasible combination has a higher benefit than the best found so far
        if current_benefit > max_overall_benefit:
            max_overall_benefit = current_benefit
            best_feasible_combination = current_combination
            best_feasible_weight = current_weight

print(f"\nFinished exploring all {1 << n} combinations.")
print(f"\nThe highest benefit among all feasible solutions is: {max_overall_benefit}")
print(f"Corresponding total weight: {best_feasible_weight:.2f} kg")
print("Items in this combination:")
for item in best_feasible_combination:
    print(f"  - {item['name']} (Weight: {item['weight']} kg, Benefit: {item['benefit']})")

# Utilizing the Greedy approach

# Calculate the benefit-to-weight ratio for each item and store it
for item in items_data:
    item['ratio'] = item['benefit'] / item['weight']

# Sort items in decreasing order based on their ratio
sorted_items = sorted(items_data, key=lambda x: x['ratio'], reverse=True)

# Initialize variables for the greedy selection
greedy_selected_items = []
current_greedy_weight = 0
current_greedy_benefit = 0

print("Greedy Approach - Items sorted by Benefit/Weight Ratio:")
for item in sorted_items:
    print(f"  - {item['name']}: Weight={item['weight']} kg, Benefit={item['benefit']}, Ratio={item['ratio']:.2f}")

# Add items to the knapsack greedily
for item in sorted_items:
    if current_greedy_weight + item['weight'] <= knapsack_capacity_kg:
        greedy_selected_items.append(item)
        current_greedy_weight += item['weight']
        current_greedy_benefit += item['benefit']
    else:
        # If the next item doesn't fit, stop for 0/1 knapsack
        # For fractional knapsack, you would add a fraction of the item
        pass

print(f"\nGreedy Solution:")
print(f"  Maximum total benefit: {current_greedy_benefit}")
print(f"  Total weight of selected items: {current_greedy_weight:.2f} kg")
print("  Selected items:")
for item in greedy_selected_items:
    print(f"    - {item['name']} (Weight: {item['weight']} kg, Benefit: {item['benefit']})")



"""## Update Problem Data

### Subtask:
Modify the `warehouses_data` to include 8 warehouses with example opening costs and `customer_costs_data` to include 10 customers with example costs to be served from each of the 8 warehouses. Print the updated data for verification.

**Reasoning**:
The subtask requires defining `warehouses_data` and `customer_costs_data` with new, expanded example data for 8 warehouses and 10 customers, and then printing them for verification. This code block will initialize and display the updated data structures.
"""

import random

# 1. Define warehouses_data with 8 warehouses
warehouses_data = [
    {'name': 'Warehouse A', 'opening_cost': 100},
    {'name': 'Warehouse B', 'opening_cost': 75},
    {'name': 'Warehouse C', 'opening_cost': 120},
    {'name': 'Warehouse D', 'opening_cost': 90},
    {'name': 'Warehouse E', 'opening_cost': 110},
    {'name': 'Warehouse F', 'opening_cost': 80},
    {'name': 'Warehouse G', 'opening_cost': 130},
    {'name': 'Warehouse H', 'opening_cost': 95}
]

# 2. Define customer_costs_data with 10 customers and costs for all 8 warehouses
customer_costs_data = []
warehouse_names = [wh['name'] for wh in warehouses_data]

for i in range(1, 11): # 10 customers
    customer_entry = {'customer': f'Customer {i}'}
    for wh_name in warehouse_names:
        # Generate random costs between 5 and 25 for example
        customer_entry[wh_name] = random.randint(5, 25)
    customer_costs_data.append(customer_entry)

# 3. Print the updated data for verification
print("Updated Warehouse Data:")
for warehouse in warehouses_data:
    print(warehouse)

print("\nUpdated Customer Costs Data:")
for customer_cost in customer_costs_data:
    print(customer_cost)

"""## Generate All Warehouse-Opening Solutions

### Subtask:
Systematically generate every possible combination of warehouses that could be opened from the updated set of 8 potential locations.

**Reasoning**:
The subtask requires generating all possible combinations of warehouses from the updated `warehouses_data` using a bitmask approach, similar to a previous step but with the new data. I will iterate through all possible subsets and store each combination as a list of warehouse names.
"""

n_warehouses = len(warehouses_data)
all_warehouse_combinations = []

print(f"Total potential warehouses: {n_warehouses}")

# Iterate through all possible subsets using a bitmask approach
for i in range(1 << n_warehouses): # Loop from 0 to 2^n - 1
    current_combination_names = []
    for j in range(n_warehouses):
        # Check if the j-th warehouse is in the current subset
        if (i >> j) & 1:
            current_combination_names.append(warehouses_data[j]['name'])
    all_warehouse_combinations.append(current_combination_names)

print(f"Generated {len(all_warehouse_combinations)} possible warehouse combinations.")
# For brevity, let's print the first few combinations
# for i, combo in enumerate(all_warehouse_combinations):
#     if i >= 10: break # Print first 10 combinations
#     print(f"  - {combo}")

"""**Reasoning**:
Now that all possible warehouse combinations have been generated for the updated data, the next step is to evaluate each combination. This involves calculating the total opening cost for the selected warehouses, assigning each customer to the cheapest available warehouse within that combination, summing up the customer service costs, and finally, calculating the overall total cost for each solution. This process is crucial for identifying the optimal configurations.


"""

all_solutions = []

# Helper function to get opening cost by warehouse name
def get_opening_cost(warehouse_name, warehouses_data):
    for wh in warehouses_data:
        if wh['name'] == warehouse_name:
            return wh['opening_cost']
    return 0 # Should not happen if data is consistent

print(f"Processing {len(all_warehouse_combinations)} warehouse combinations...")

for combination in all_warehouse_combinations:
    opening_cost_sum = 0
    customer_service_cost_sum = 0
    customer_assignments = {}

    # Calculate opening_cost_sum for the current combination
    for wh_name in combination:
        opening_cost_sum += get_opening_cost(wh_name, warehouses_data)

    # For each customer, find the minimum service cost among the opened warehouses
    for customer_data in customer_costs_data:
        customer_name = customer_data['customer']
        min_customer_cost = float('inf')
        assigned_warehouse = None

        # Iterate through each warehouse_name that is in the current combination
        for warehouse_name_in_combo in combination:
            if warehouse_name_in_combo in customer_data:
                cost = customer_data[warehouse_name_in_combo]
                if cost < min_customer_cost:
                    min_customer_cost = cost
                    assigned_warehouse = warehouse_name_in_combo

        # Handle cases where no warehouse is open or no warehouse can serve a customer
        if assigned_warehouse is None and len(combination) > 0: # A customer cannot be served by any opened warehouse
            customer_service_cost_sum = float('inf') # Mark as infeasible
            break # Stop processing this combination, it's infeasible
        elif assigned_warehouse is None and len(combination) == 0: # If no warehouses are open
            min_customer_cost = float('inf') # No warehouse to serve, so cost is infinite

        customer_service_cost_sum += min_customer_cost
        customer_assignments[customer_name] = assigned_warehouse

    # Calculate total_cost, handling infeasible cases
    if customer_service_cost_sum == float('inf'):
        total_cost = float('inf')
    else:
        total_cost = opening_cost_sum + customer_service_cost_sum

    # Append solution details to all_solutions list
    all_solutions.append({
        'combination': combination,
        'opening_cost_sum': opening_cost_sum,
        'customer_service_cost_sum': customer_service_cost_sum,
        'total_cost': total_cost,
        'customer_assignments': customer_assignments
    })

print(f"Calculated costs for {len(all_solutions)} solutions.")

"""**Reasoning**:
The subtask requires identifying the overall optimal warehouse configuration by finding the solution with the minimum total cost from the `all_solutions` list. I will iterate through `all_solutions` to find the best configuration and then print its details.


"""

min_total_cost = float('inf')
best_solution = None

for solution in all_solutions:
    if solution['total_cost'] < min_total_cost:
        min_total_cost = solution['total_cost']
        best_solution = solution

print("\n--- Overall Optimal Warehouse Configuration ---")
if best_solution:
    print(f"Selected Warehouses: {best_solution['combination']}")
    print(f"Total Opening Cost: {best_solution['opening_cost_sum']}")
    print(f"Total Customer Service Cost: {best_solution['customer_service_cost_sum']}")
    print(f"Overall Minimum Total Cost: {best_solution['total_cost']}")
    print("Customer Assignments:")
    for customer, warehouse in best_solution['customer_assignments'].items():
        print(f"  - {customer} assigned to {warehouse}")
else:
    print("No feasible solution found.")

"""**Reasoning**:
I need to filter the `all_solutions` to find configurations with exactly 3 warehouses and then identify the one with the minimum total cost, similar to the previous task but with an added filter.


"""

min_total_cost_3_warehouses = float('inf')
best_solution_3_warehouses = None

# Filter solutions to only include combinations with exactly 3 warehouses
three_warehouse_solutions = [s for s in all_solutions if len(s['combination']) == 3]

for solution in three_warehouse_solutions:
    if solution['total_cost'] < min_total_cost_3_warehouses:
        min_total_cost_3_warehouses = solution['total_cost']
        best_solution_3_warehouses = solution

print("\n--- Optimal Warehouse Configuration with Exactly 3 Warehouses ---")
if best_solution_3_warehouses:
    print(f"Selected Warehouses: {best_solution_3_warehouses['combination']}")
    print(f"Total Opening Cost: {best_solution_3_warehouses['opening_cost_sum']}")
    print(f"Total Customer Service Cost: {best_solution_3_warehouses['customer_service_cost_sum']}")
    print(f"Overall Minimum Total Cost (3 Warehouses): {best_solution_3_warehouses['total_cost']}")
    print("Customer Assignments:")
    for customer, warehouse in best_solution_3_warehouses['customer_assignments'].items():
        print(f"  - {customer} assigned to {warehouse}")
else:
    print("No feasible solution found with exactly 3 warehouses.")

"""## Summary of Warehouse-Opening Problem

This analysis aimed to find the optimal warehouse configuration to minimize total costs, considering both opening costs and customer service costs. The problem was updated with 8 potential warehouse locations and 10 customer locations.

### Overall Optimal Warehouse Configuration

*   **Selected Warehouses:** ['Warehouse F']
*   **Total Opening Cost:** 80
*   **Total Customer Service Cost:** 109
*   **Overall Minimum Total Cost:** 189
*   **Customer Assignments:** All 10 customers are assigned to 'Warehouse F'.

**Insight:** The overall optimal solution indicates that opening only a single warehouse ('Warehouse F') provides the lowest total cost. This suggests that 'Warehouse F' has a highly advantageous combination of low opening cost and efficient customer service costs for the given customer distribution.

### Optimal Warehouse Configuration with Exactly 3 Warehouses

*   **Selected Warehouses:** ['Warehouse B', 'Warehouse D', 'Warehouse F']
*   **Total Opening Cost:** 245
*   **Total Customer Service Cost:** 67
*   **Overall Minimum Total Cost (3 Warehouses):** 312
*   **Customer Assignments:**
    *   Customer 1 assigned to Warehouse B
    *   Customer 2 assigned to Warehouse D
    *   Customer 3 assigned to Warehouse B
    *   Customer 4 assigned to Warehouse F
    *   Customer 5 assigned to Warehouse D
    *   Customer 6 assigned to Warehouse F
    *   Customer 7 assigned to Warehouse D
    *   Customer 8 assigned to Warehouse F
    *   Customer 9 assigned to Warehouse F
    *   Customer 10 assigned to Warehouse D

**Insight:** When restricted to exactly 3 warehouses, the optimal combination includes 'Warehouse B', 'Warehouse D', and 'Warehouse F'. While this configuration results in a higher total cost (312) compared to the overall optimal single-warehouse solution (189), it achieves a lower customer service cost (67 vs. 109). This indicates that spreading customers across multiple strategically located warehouses can reduce service costs, but the increased opening costs might outweigh these savings in an unconstrained scenario.

### Key Takeaways:

1.  **Single Warehouse Dominance:** For the given data, a single warehouse ('Warehouse F') proves to be the most cost-effective solution overall due to its balanced opening and service costs.
2.  **Trade-off between Opening and Service Costs:** The analysis highlights the critical trade-off between the fixed costs of opening warehouses and the variable costs of serving customers. Adding more warehouses can reduce customer service costs by placing facilities closer to customers, but this benefit must be weighed against the additional opening expenses.
3.  **Scalability:** As the number of potential warehouses and customers increases, exhaustive search becomes computationally intensive. For larger problems, approximation algorithms or optimization techniques would be more practical.

## Summary of Warehouse-Opening Problem

This analysis aimed to find the optimal warehouse configuration to minimize total costs, considering both opening costs and customer service costs. The problem was updated with 8 potential warehouse locations and 10 customer locations.

### Overall Optimal Warehouse Configuration

*   **Selected Warehouses:** ['Warehouse F']
*   **Total Opening Cost:** 80
*   **Total Customer Service Cost:** 109
*   **Overall Minimum Total Cost:** 189
*   **Customer Assignments:** All 10 customers are assigned to 'Warehouse F'.

**Insight:** The overall optimal solution indicates that opening only a single warehouse ('Warehouse F') provides the lowest total cost. This suggests that 'Warehouse F' has a highly advantageous combination of low opening cost and efficient customer service costs for the given customer distribution.

### Optimal Warehouse Configuration with Exactly 3 Warehouses

*   **Selected Warehouses:** ['Warehouse B', 'Warehouse D', 'Warehouse F']
*   **Total Opening Cost:** 245
*   **Total Customer Service Cost:** 67
*   **Overall Minimum Total Cost (3 Warehouses):** 312
*   **Customer Assignments:**
    *   Customer 1 assigned to Warehouse B
    *   Customer 2 assigned to Warehouse D
    *   Customer 3 assigned to Warehouse B
    *   Customer 4 assigned to Warehouse F
    *   Customer 5 assigned to Warehouse D
    *   Customer 6 assigned to Warehouse F
    *   Customer 7 assigned to Warehouse D
    *   Customer 8 assigned to Warehouse F
    *   Customer 9 assigned to Warehouse F
    *   Customer 10 assigned to Warehouse D

**Insight:** When restricted to exactly 3 warehouses, the optimal combination includes 'Warehouse B', 'Warehouse D', and 'Warehouse F'. While this configuration results in a higher total cost (312) compared to the overall optimal single-warehouse solution (189), it achieves a lower customer service cost (67 vs. 109). This indicates that spreading customers across multiple strategically located warehouses can reduce service costs, but the increased opening costs might outweigh these savings in an unconstrained scenario.

### Key Takeaways:

1.  **Single Warehouse Dominance:** For the given data, a single warehouse ('Warehouse F') proves to be the most cost-effective solution overall due to its balanced opening and service costs.
2.  **Trade-off between Opening and Service Costs:** The analysis highlights the critical trade-off between the fixed costs of opening warehouses and the variable costs of serving customers. Adding more warehouses can reduce customer service costs by placing facilities closer to customers, but this benefit must be weighed against the additional opening expenses.
3.  **Scalability:** As the number of potential warehouses and customers increases, exhaustive search becomes computationally intensive. For larger problems, approximation algorithms or optimization techniques would be more practical.

## Final Task

### Subtask:
Summarize the results of the exhaustive search, highlighting both the overall optimal warehouse configuration and its total cost, as well as the optimal configuration and cost when exactly 3 warehouses are selected.

## Summary:

### Q&A
*   **Overall optimal warehouse configuration and its total cost:** The overall optimal configuration involves opening only 'Warehouse F', resulting in a total cost of \$189.
*   **Optimal configuration and cost when exactly 3 warehouses are selected:** The optimal configuration when exactly 3 warehouses are selected is 'Warehouse B', 'Warehouse D', and 'Warehouse F', with a total cost of \$312.

### Data Analysis Key Findings
*   The analysis was performed using data for 8 potential warehouses and 10 customers.
*   The exhaustive search method generated 256 possible warehouse combinations.
*   The overall optimal warehouse configuration, minimizing total cost, is 'Warehouse F'. This configuration has a total opening cost of \$80, a total customer service cost of \$109, and an overall minimum total cost of \$189. All 10 customers are assigned to 'Warehouse F' in this scenario.
*   When constrained to exactly 3 warehouses, the optimal configuration is 'Warehouse B', 'Warehouse D', and 'Warehouse F'. This configuration has a total opening cost of \$245, a total customer service cost of \$67, and an overall minimum total cost of \$312.

### Insights or Next Steps
*   The analysis highlights a significant trade-off between fixed opening costs and variable customer service costs; while opening more warehouses can reduce customer service costs (from \$109 to \$67 when going from 1 to 3 warehouses), the increased opening costs (from \$80 to \$245) can lead to a higher overall total cost.
*   For larger-scale problems with more potential warehouses, the exhaustive search method used here becomes computationally impractical. Future analyses should consider employing approximation algorithms or more advanced optimization techniques to find solutions efficiently.

# Task
Create a text file named 'greedy_warehouse_data.txt' and populate it with the warehouse opening costs and customer service costs for the 8 warehouses and 10 customers that were defined previously. The file will be formatted to allow easy parsing in subsequent steps. This includes a section for warehouse data (name, opening cost) and a section for customer costs (customer name, cost to each warehouse).

## Prepare Data for Greedy Algorithm

### Subtask:
Create a text file named 'greedy_warehouse_data.txt' and populate it with the warehouse opening costs and customer service costs for the 8 warehouses and 10 customers that were defined previously. The file will be formatted to allow easy parsing in subsequent steps. This includes a section for warehouse data (name, opening cost) and a section for customer costs (customer name, cost to each warehouse).

**Reasoning**:
The subtask requires writing the `warehouses_data` and `customer_costs_data` to a text file in a specific format. I will open the file, write the warehouse information, and then write the customer costs.
"""

output_file_name = 'greedy_warehouse_data.txt'

with open(output_file_name, 'w') as f:
    # Write warehouse data
    f.write('WAREHOUSES:\n')
    for warehouse in warehouses_data:
        f.write(f"{warehouse['name']},{warehouse['opening_cost']}\n")

    # Write customer costs data
    f.write('CUSTOMER_COSTS:\n')
    warehouse_names_ordered = [wh['name'] for wh in warehouses_data]
    for customer_cost in customer_costs_data:
        customer_name = customer_cost['customer']
        costs = [str(customer_cost[wh_name]) for wh_name in warehouse_names_ordered]
        f.write(f"{customer_name},{','.join(costs)}\n")

print(f"Data successfully written to '{output_file_name}'.")

"""## Read Data from Text File

### Subtask:
Read the warehouse and customer data for the greedy algorithm from the 'greedy_warehouse_data.txt' file into appropriate Python data structures (e.g., lists of dictionaries).

**Reasoning**:
The subtask requires reading data from the 'greedy_warehouse_data.txt' file. I need to parse the warehouse and customer cost information into two separate data structures, `warehouses_data_greedy` and `customer_costs_data_greedy`, as specified in the instructions. This will involve iterating through the file, identifying sections, and parsing lines accordingly.
"""

warehouses_data_greedy = []
customer_costs_data_greedy = []

output_file_name = 'greedy_warehouse_data.txt'

current_section = None
warehouse_names_ordered = [] # To store order of warehouses for customer costs

with open(output_file_name, 'r') as f:
    for line in f:
        line = line.strip()
        if not line:
            continue # Skip empty lines

        if line == 'WAREHOUSES:':
            current_section = 'WAREHOUSES'
            continue
        elif line == 'CUSTOMER_COSTS:':
            current_section = 'CUSTOMER_COSTS'
            continue

        if current_section == 'WAREHOUSES':
            name, cost_str = line.split(',')
            opening_cost = int(cost_str)
            warehouses_data_greedy.append({'name': name, 'opening_cost': opening_cost})
            warehouse_names_ordered.append(name) # Keep track of warehouse order
        elif current_section == 'CUSTOMER_COSTS':
            parts = line.split(',')
            customer_name = parts[0]
            costs_str = parts[1:]
            customer_entry = {'customer': customer_name}
            for i, wh_name in enumerate(warehouse_names_ordered):
                customer_entry[wh_name] = int(costs_str[i])
            customer_costs_data_greedy.append(customer_entry)

print("Warehouses data for Greedy Algorithm (read from file):")
for wh in warehouses_data_greedy:
    print(wh)

print("\nCustomer costs data for Greedy Algorithm (read from file):")
for cust_cost in customer_costs_data_greedy:
    print(cust_cost)

"""## Implement Greedy Algorithm

### Subtask:
Define and implement a greedy algorithm to select warehouses. The algorithm will iterate through potential warehouses, adding the one that provides the most immediate cost reduction or benefit until all customers are served or no further improvements can be made. This step will also include assigning each customer to the cheapest open warehouse after each selection.

**Reasoning**:
To implement the greedy algorithm, I first need a helper function to calculate the total cost (opening + customer service) for a given set of selected warehouses. This function will be crucial for evaluating potential warehouse additions in each greedy step.
"""

def calculate_total_cost_greedy(selected_warehouse_names, all_warehouses_data, all_customer_costs_data):
    opening_cost_sum = 0
    customer_service_cost_sum = 0
    customer_assignments = {}

    # Calculate opening_cost_sum for the selected warehouses
    for wh_name in selected_warehouse_names:
        for wh in all_warehouses_data:
            if wh['name'] == wh_name:
                opening_cost_sum += wh['opening_cost']
                break

    # For each customer, find the minimum service cost among the selected warehouses
    for customer_data in all_customer_costs_data:
        customer_name = customer_data['customer']
        min_customer_cost = float('inf')
        assigned_warehouse = None

        for wh_name_in_combo in selected_warehouse_names:
            if wh_name_in_combo in customer_data:
                cost = customer_data[wh_name_in_combo]
                if cost < min_customer_cost:
                    min_customer_cost = cost
                    assigned_warehouse = wh_name_in_combo

        # If no warehouse is selected, or a customer cannot be served by any selected warehouse,
        # the cost for that customer is considered infinite for this combination.
        if assigned_warehouse is None and len(selected_warehouse_names) > 0:
            # This case implies an infeasible solution for this customer if there are open warehouses
            # but none can serve them (shouldn't happen with our data where all warehouses can serve all customers).
            # Or, more practically, if no warehouse is open, service cost is infinite.
            customer_service_cost_sum = float('inf')
            break
        elif assigned_warehouse is None and len(selected_warehouse_names) == 0:
            # If no warehouses are open, all customer service costs are infinite
            customer_service_cost_sum = float('inf')
            break
        else:
            customer_service_cost_sum += min_customer_cost
            customer_assignments[customer_name] = assigned_warehouse

    if customer_service_cost_sum == float('inf'):
        total_cost = float('inf')
    else:
        total_cost = opening_cost_sum + customer_service_cost_sum

    return total_cost, customer_assignments

print("Helper function 'calculate_total_cost_greedy' defined.")

"""**Reasoning**:
Now that the helper function `calculate_total_cost_greedy` is defined, I will implement the main greedy algorithm. This involves iteratively selecting the warehouse that results in the greatest reduction in the overall total cost, until no further cost improvements can be made by adding another warehouse.


"""

greedy_selected_warehouses = []
current_total_cost_greedy = float('inf')
current_opening_cost_greedy = 0 # Will be updated with total_cost
customer_assignments_greedy = {}

# Get all potential warehouse names for iteration
all_potential_warehouse_names = [wh['name'] for wh in warehouses_data_greedy]

print("Starting Greedy Warehouse Selection...")

while True:
    best_marginal_warehouse = None
    # Initialize with current total cost to check for improvements
    min_potential_total_cost_this_iteration = current_total_cost_greedy
    best_marginal_assignments_this_iteration = {}

    # Iterate through warehouses not yet selected
    for wh_name_to_consider in all_potential_warehouse_names:
        if wh_name_to_consider not in greedy_selected_warehouses:
            # Create a temporary list of selected warehouses including the current candidate
            potential_selected_warehouses = greedy_selected_warehouses + [wh_name_to_consider]

            # Calculate the total cost if this warehouse were added
            potential_cost, potential_assignments = calculate_total_cost_greedy(
                potential_selected_warehouses,
                warehouses_data_greedy,
                customer_costs_data_greedy
            )

            # Check if this addition results in a better (lower) total cost
            if potential_cost < min_potential_total_cost_this_iteration:
                min_potential_total_cost_this_iteration = potential_cost
                best_marginal_warehouse = wh_name_to_consider
                best_marginal_assignments_this_iteration = potential_assignments

    # If no warehouse improved the total cost or if the cost is still infinite (no feasible solution found yet)
    # and we haven't selected any warehouses, stop.
    if best_marginal_warehouse is None or (min_potential_total_cost_this_iteration == float('inf') and not greedy_selected_warehouses):
        # If the current best solution is still infinite, it means no warehouses can serve all customers for a finite cost.
        # This handles the edge case where no warehouse can individually serve all customers.
        if current_total_cost_greedy == float('inf'):
            print("No feasible greedy solution found where all customers can be served.")
        break # No improvement found or no feasible solution possible

    # If an improvement was found, update the main solution
    if min_potential_total_cost_this_iteration < current_total_cost_greedy:
        greedy_selected_warehouses.append(best_marginal_warehouse)
        current_total_cost_greedy = min_potential_total_cost_this_iteration
        customer_assignments_greedy = best_marginal_assignments_this_iteration
        # Update opening cost for printing later, if needed (it's embedded in current_total_cost_greedy now)
        current_opening_cost_greedy = sum(wh['opening_cost'] for wh in warehouses_data_greedy if wh['name'] in greedy_selected_warehouses)
        print(f"  Added '{best_marginal_warehouse}'. Current Total Cost: {current_total_cost_greedy}")
    else:
        # No further improvement possible with any remaining warehouse
        break

print("\n--- Greedy Algorithm Solution ---")
if current_total_cost_greedy != float('inf'):
    print(f"Selected Warehouses: {greedy_selected_warehouses}")
    print(f"Total Opening Cost: {current_opening_cost_greedy}")
    # Calculate total customer service cost for the final selected warehouses
    final_customer_service_cost = current_total_cost_greedy - current_opening_cost_greedy
    print(f"Total Customer Service Cost: {final_customer_service_cost}")
    print(f"Overall Minimum Total Cost (Greedy): {current_total_cost_greedy}")
    print("Customer Assignments:")
    for customer, warehouse in customer_assignments_greedy.items():
        print(f"  - {customer} assigned to {warehouse}")
else:
    print("No feasible solution found by the greedy algorithm.")

"""## Final Task

### Subtask:
Summarize the results of the greedy algorithm, highlighting the selected warehouses and the total cost, and compare it to the previously found optimal solution from the exhaustive search.

## Summary:

### Data Analysis Key Findings
*   A text file named `greedy_warehouse_data.txt` was successfully created and populated. It contains two sections: `WAREHOUSES:` listing warehouse names and opening costs (e.g., 'Warehouse A',100), and `CUSTOMER_COSTS:` listing customer names followed by their service costs to each warehouse (e.g., 'Customer 1',24,5,...).
*   The data from `greedy_warehouse_data.txt` was successfully read into Python data structures: `warehouses_data_greedy` (8 dictionaries with name and opening cost) and `customer_costs_data_greedy` (10 dictionaries with customer name and service costs to each of the 8 warehouses).
*   The implemented greedy algorithm selected 'Warehouse F' as the single optimal warehouse based on its selection criteria.
*   The total cost for the greedy solution was \$189. This cost was composed of an opening cost of \$80 for 'Warehouse F' and a total customer service cost of \$109.
*   All 10 customers were assigned to 'Warehouse F' under this greedy solution.

### Insights or Next Steps
*   The greedy algorithm provided a quick solution, but it's important to compare this total cost of \$189 with solutions from other optimization methods (e.g., exhaustive search or linear programming) to evaluate its efficiency and optimality.
*   Given that only one warehouse ('Warehouse F') was selected by the greedy approach, a next step could involve analyzing why 'Warehouse F' was singularly attractive in terms of combined opening and service costs for all customers compared to other warehouses.
"""