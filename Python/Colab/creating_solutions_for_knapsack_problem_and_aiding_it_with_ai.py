# -*- coding: utf-8 -*-
"""Creating solutions for knapsack problem and aiding it with AI

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OBGDtT6PaAuUJqw5V3otHcsgrspiLnFe

### Knapsack Problem Solution

This notebook will solve the 0/1 knapsack problem for the given items and knapsack capacity. The goal is to maximize the total benefit of items placed in the knapsack without exceeding its weight capacity.

Since the item weights include decimal values, we will scale all weights and the knapsack capacity by a factor of 100 to convert them into integers. This allows us to use a standard dynamic programming approach for the 0/1 knapsack problem.

Let's define the items and the knapsack capacity first.
"""

# Define the items: each item is a dictionary with 'name', 'weight', and 'benefit'
items_data = [
    {'name': 'Water', 'weight': 2, 'benefit': 7},
    {'name': 'Chocolate', 'weight': 0.25, 'benefit': 10},
    {'name': 'Gatorade', 'weight': 1.1, 'benefit': 7},
    {'name': 'Camera', 'weight': 2, 'benefit': 6},
    {'name': 'Raincoat', 'weight': 0.75, 'benefit': 3},
    {'name': 'Towel', 'weight': 0.8, 'benefit': 5},
    {'name': 'First Aid Kit', 'weight': 3, 'benefit': 10},
    {'name': 'Flashlight', 'weight': 1.5, 'benefit': 7},
    {'name': 'Fruit', 'weight': 2.5, 'benefit': 8},
    {'name': 'Sandwiches', 'weight': 0.5, 'benefit': 5},
    {'name': 'Tacos', 'weight': 0.75, 'benefit': 8},
    {'name': 'Sleeping Bag', 'weight': 2.3, 'benefit': 4},
    {'name': 'Book', 'weight': 1.3, 'benefit': 8},
    {'name': 'Sunscreen', 'weight': 0.45, 'benefit': 9},
    {'name': 'Champagne', 'weight': 1.1, 'benefit': 5}
]

# Define the knapsack capacity
knapsack_capacity_kg = 10

# Scaling factor to convert decimal weights to integers
scaling_factor = 100

# Prepare items with scaled weights
items = []
for item in items_data:
    scaled_weight = int(item['weight'] * scaling_factor)
    items.append({'name': item['name'], 'weight': scaled_weight, 'benefit': item['benefit']})

scaled_knapsack_capacity = int(knapsack_capacity_kg * scaling_factor)

print(f"Original Knapsack Capacity: {knapsack_capacity_kg} kg")
print(f"Scaled Knapsack Capacity: {scaled_knapsack_capacity}")
print("Scaled Items:")
for item in items:
    print(f"  - {item['name']}: Weight={item['weight']}, Benefit={item['benefit']}")

# Knapsack solving algorithm

def solve_knapsack(items, capacity):
    n = len(items)
    # dp[i][w] will store the maximum benefit for first i items with capacity w
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]

    # Populate the dp table
    for i in range(1, n + 1):
        weight_i = items[i-1]['weight']
        benefit_i = items[i-1]['benefit']

        for w in range(1, capacity + 1):
            if weight_i <= w:
                # Option 1: Include item i
                # Option 2: Exclude item i
                dp[i][w] = max(benefit_i + dp[i-1][w - weight_i], dp[i-1][w])
            else:
                # Cannot include item i due to weight constraint
                dp[i][w] = dp[i-1][w]

    # The maximum benefit is in dp[n][capacity]
    max_benefit = dp[n][capacity]

    # Reconstruct the selected items
    selected_items = []
    w = capacity
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:
            selected_items.append(items_data[i-1]) # Use original item data for output
            w -= items[i-1]['weight']

    return max_benefit, selected_items

# Solve the knapsack problem with scaled values
max_benefit, selected_items_original = solve_knapsack(items, scaled_knapsack_capacity)

print(f"\nMaximum total benefit: {max_benefit}")
print("Selected items:")

total_weight_selected = 0
for item in selected_items_original:
    print(f"  - {item['name']} (Weight: {item['weight']} kg, Benefit: {item['benefit']})")
    total_weight_selected += item['weight']

print(f"Total weight of selected items: {total_weight_selected:.2f} kg")
print(f"Knapsack capacity: {knapsack_capacity_kg} kg")

# Brute force method

import itertools

# Re-using items_data and knapsack_capacity_kg from previous cells
# items_data = [
#     {'name': 'Agua', 'weight': 2, 'benefit': 7},
#     ... (full list as defined previously)
# ]
# knapsack_capacity_kg = 10

max_overall_benefit = 0
best_feasible_combination = []
best_feasible_weight = 0

n = len(items_data)

print("Exploring all possible combinations...")

# Iterate through all possible subsets (combinations) of items
# A bitmask approach effectively generates all 2^n subsets
for i in range(1 << n): # Loop from 0 to 2^n - 1
    current_combination = []
    current_weight = 0
    current_benefit = 0

    for j in range(n):
        # Check if the j-th item is in the current subset (represented by the i-th bit)
        if (i >> j) & 1:
            current_combination.append(items_data[j])
            current_weight += items_data[j]['weight']
            current_benefit += items_data[j]['benefit']

    # Check if the current combination is feasible (does not exceed knapsack capacity)
    if current_weight <= knapsack_capacity_kg:
        # Check if this feasible combination has a higher benefit than the best found so far
        if current_benefit > max_overall_benefit:
            max_overall_benefit = current_benefit
            best_feasible_combination = current_combination
            best_feasible_weight = current_weight

print(f"\nFinished exploring all {1 << n} combinations.")
print(f"\nThe highest benefit among all feasible solutions is: {max_overall_benefit}")
print(f"Corresponding total weight: {best_feasible_weight:.2f} kg")
print("Items in this combination:")
for item in best_feasible_combination:
    print(f"  - {item['name']} (Weight: {item['weight']} kg, Benefit: {item['benefit']})")

# Utilizing the Greedy approach

# Calculate the benefit-to-weight ratio for each item and store it
for item in items_data:
    item['ratio'] = item['benefit'] / item['weight']

# Sort items in decreasing order based on their ratio
sorted_items = sorted(items_data, key=lambda x: x['ratio'], reverse=True)

# Initialize variables for the greedy selection
greedy_selected_items = []
current_greedy_weight = 0
current_greedy_benefit = 0

print("Greedy Approach - Items sorted by Benefit/Weight Ratio:")
for item in sorted_items:
    print(f"  - {item['name']}: Weight={item['weight']} kg, Benefit={item['benefit']}, Ratio={item['ratio']:.2f}")

# Add items to the knapsack greedily
for item in sorted_items:
    if current_greedy_weight + item['weight'] <= knapsack_capacity_kg:
        greedy_selected_items.append(item)
        current_greedy_weight += item['weight']
        current_greedy_benefit += item['benefit']
    else:
        # If the next item doesn't fit, stop for 0/1 knapsack
        # For fractional knapsack, you would add a fraction of the item
        pass

print(f"\nGreedy Solution:")
print(f"  Maximum total benefit: {current_greedy_benefit}")
print(f"  Total weight of selected items: {current_greedy_weight:.2f} kg")
print("  Selected items:")
for item in greedy_selected_items:
    print(f"    - {item['name']} (Weight: {item['weight']} kg, Benefit: {item['benefit']})")

